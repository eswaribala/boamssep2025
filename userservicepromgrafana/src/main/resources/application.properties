# App identity
spring.application.name=user-role-service
#data source connection pool
drivername=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://mysql:3306/boatraderproddb?useSSL=true
mysqlusername=root
mysqlpassword=password

spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=12
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000



# Choose active schema at startup (VM arg/env can override)
#app.active-schema=${APP_ACTIVE_SCHEMA:payment}   # -Dapp.active-schema=loan
#
## Do NOT set spring.datasource.*; custom @Primary DataSource beans will handle it
#app.datasource.payment.jdbc-url=jdbc:mysql://localhost:3306/paymentdb
#app.datasource.payment.username=root
#app.datasource.payment.password=vignesh
#app.datasource.payment.driver-class-name=com.mysql.cj.jdbc.Driver
#
#app.datasource.loan.jdbc-url=jdbc:mysql://localhost:3306/loandb
#app.datasource.loan.username=root
#app.datasource.loan.password=vignesh
#app.datasource.loan.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

management.endpoints.web.exposure.include=*

#jpa properties
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.database=default
spring.jpa.show-sql=true
#logging.level.org.hibernate.SQL=DEBUG
#logging.level.org.hibernate.orm.jdbc.bind=TRACE
#DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
#spring.datasource.continue-on-error=false
spring.datasource.generate-unique-name=false
spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
spring.jackson.serialization.fail-on-empty-beans=false
spring.main.allow-circular-references=true
#spring.devtools.restart.enabled=false
#spring.devtools.restart.additional-exclude=com/boa/userservice/logging/**
server.port=7076

# GraphQL
#graphql
graphql.graphiql.mapping=/graphiql
graphql.graphiql.endpoint.graphql=/graphql
graphql.graphiql.enabled=true


#actuator and prometheus
management.endpoint.metrics.enabled=true
management.endpoint.prometheus.enabled=true
management.prometheus.metrics.export.enabled=true

# 100% sampling in dev; lower in prod (e.g., 0.1)
management.tracing.sampling.probability=1.0

# Send traces to Jaeger Collector via OTLP gRPC (recommended)
# Pick ONE of the following based on where your app runs:

# App on HOST, Jaeger on HOST (or Docker with 4317 mapped):
#management.otlp.tracing.endpoint=http://localhost:4317

# App IN DOCKER, Jaeger on HOST (Docker Desktop):
management.otlp.tracing.endpoint=http://host.docker.internal:4317

# App IN DOCKER, Jaeger IN DOCKER (same network, service name "jaeger"):
# management.otlp.tracing.endpoint=http://jaeger:4317

# Optional: add both W3C + B3 propagation if you have polyglot callers
management.tracing.propagation.type=w3c,b3
# Show trace/span IDs in logs
logging.pattern.level=%5p [${spring.application.name:},traceId=%X{traceId:-},spanId=%X{spanId:-}]